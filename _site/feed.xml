<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>coder_yu&#39;s BLOG</title>
    <description>这里的文章排版比较丑，有时间了在慢慢整理，简书上的排版会好很多~~欢迎指出文章中的错误或者不足之处.</description>
    <link>http://yourdomain.com/</link>
    <atom:link href="http://yourdomain.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 13 Mar 2017 23:39:50 +0800</pubDate>
    <lastBuildDate>Mon, 13 Mar 2017 23:39:50 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>图解https的一些小动作</title>
        <description>&lt;p&gt;看了大半天，总算将https的整个握手过程都看的差不多了，之前网上看过很多资料，描述的都差不多，也让我对于整个过程有一个大致的概念了，但是我想知道的一些关键点都没讲出来，基本都是一笔带过，然后也就没有再继续找了，这次想起来，又重新找资料，找到两篇很详细的文章介绍了，其中第二篇还介绍了一些算法层次的内容，有兴趣研究的同学可以看看，我这边只是稍做简化并将它图形化了，让读者有一个更直观的感受。&lt;/p&gt;

&lt;p&gt;参考文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/a766bbf31417&quot;&gt;http://www.jianshu.com/p/a766bbf31417&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/zgwangbo/article/details/50889623&quot;&gt;http://blog.csdn.net/zgwangbo/article/details/50889623&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;废话不多说，直接po图：
&lt;img src=&quot;https.png&quot; alt=&quot;https.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于之前了解过https过程的小伙伴，仔细看这个图应该会解开一些迷惑吧，仔细看！包括那些字母和脚标！但是！我还是稍微解释下吧，毕竟还是要凑点字数的……&lt;/p&gt;

&lt;p&gt;概念的介绍啥的我就不说了，直接开始正文吧。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ClientHello。 首先https请求是基于http的，也就是基于tcp的，所以先得建立tcp三次握手，这个就不说了，然后tcp握手后是SSL层的握手，也就是图中的ClientHello消息，client发送本地最新的TLS版本、算法组合的一个集合和其他很多辅助的信息，并且生成一个随机数A。具体的内容可以看下图（&lt;code class=&quot;highlighter-rouge&quot;&gt;ClientHello.png&lt;/code&gt;）：
&lt;img src=&quot;ClientHello.png&quot; alt=&quot;ClientHello.png&quot; /&gt;
可以看到随机数（&lt;code class=&quot;highlighter-rouge&quot;&gt;Random&lt;/code&gt;）是一个GMT UNIX时间加上一串随机字节，算法组合（&lt;code class=&quot;highlighter-rouge&quot;&gt;Cipher Suite&lt;/code&gt;）有26种。还有ClientHello并不是我随便叫叫的，真的叫ClientHello😢……&lt;/li&gt;
  &lt;li&gt;ServerHello。Server收到这些信息后比对自己的TLS版本，选择其中低的一个作为返回，并且从算法组合的集合中选出一种合适的组合，然后同样也生成一个随机数B，一起打包到ServerHello中传回给Client。内容如图（&lt;code class=&quot;highlighter-rouge&quot;&gt;ServerHello.png&lt;/code&gt;）：
&lt;img src=&quot;ServerHello.png&quot; alt=&quot;ServerHello.png&quot; /&gt;
同样ServerHello也不是随便叫的，可以看到随机数格式和ClientHello一样，并且这里选出了一种CipherSuite算法组合。&lt;/li&gt;
  &lt;li&gt;Certificatie,ServerHelloDone。服务端在选出沟通策略之后将自己的证书信息告诉Client端（&lt;code class=&quot;highlighter-rouge&quot;&gt;Certificate&lt;/code&gt;），通知Client关于秘钥更新的信息（&lt;code class=&quot;highlighter-rouge&quot;&gt;ServerkeyExchange&lt;/code&gt;），接下去就看你的了，并且表示该发的都发给你了，我的Hello结束了（&lt;code class=&quot;highlighter-rouge&quot;&gt;ServerHelloDone&lt;/code&gt;）。
&lt;img src=&quot;Certificate-ServerHelloDone.png&quot; alt=&quot;Certificate-ServerHelloDone.png&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Client收到2，3步的信息后先验证证书是不是合法的，包括它的颁发机构，域名匹配，有限期限等，这个具体的过程就不探究了，只要知道这些步骤就行了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;证书验证通过之后，生成随机数C1,然后用证书内容中的公钥通过服务器选择的非对称加密算法加密，得出为C2。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由之前的三个随机数A、B、C1通过一个伪随机函数再生成一个D，&lt;strong&gt;注意！这个是最终http真正使用的加密秘钥！！！&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由D再次通过伪随机函数生成一个秘钥组，包含6个秘钥，假设为P1,P2,P3,P4,P5,P6。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ClientKeyExchange。通知Server秘钥相关的信息，发送第5步中算出的C2给Server端。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Client端发送ClientKeyExchange之后，计算之前所有与Server端交互消息的hash值，假设为client_hash1，用步骤7中得到的其中一个P1进行加密，结果为E。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Server端收到C2后用私钥结合非对称算法解密C2，得到C1。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同样的Server端也根据A、B、C1由伪随机函数生成D(&lt;strong&gt;最终的加密秘钥！！！&lt;/strong&gt;),再由D得出秘组钥（P1-P6），因为这里涉及到的算法都是一样的，所以得出的秘钥也是一样的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Server端计算之前所有和Client端交互消息的hash值，假设为server_hash2，大家可能发现了，11、12跟Client端的6、7、9过程一致，只是少了9中的P1加密过程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这个时候Client端会发送ChangeCipherSpec消息和EncryptedHandshakeMessage消息，通知Server端接下去使用选定的加密策略来通信了，并且将第9步中的E传给了Server。（这里几个步骤的顺序只是为了好理解一点而这样排列，实际两条线是独立在处理信息的，所以先后顺序不能保证）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这个时候Client会再次计算之前握手消息的hash值，得出结果client_hash2。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Server在收到EncryptedHandshakeMessage消息带过来的E之后，利用步骤11中的P1解密E，由于加密算法和P1都是相同的，所以这里还原出了client_hash1，然后与步骤12中的server_hash2比对，如果一样说明之前的几条协商秘钥的消息都被对方正确无误的理解了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Server端再次对之前的消息做hash值，得出server_hash2，用P2进行加密结果为F，然后通过ChangeCipherSpec-EncryptedHandshakeMessage消息传给Client端。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Client收到Server的消息后根据P2解密F还原得出server_hash2，与client_hash2比对如果一致，则认为之前的交互过程都是正确无误且被对方理解的。至此，整个握手过程就结束了，之后的http数据报就会被之前确定的加密策略和加密秘钥D进行加密传输了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结：其实最终我们发现整个握手过程中并没有直接传输最终的加密秘钥D，而且交换了一些算法策略和生成D的一些参数，这样相对来说会更安全一点，直接传D的话这个过程就由Client端完成了，中间如果出什么差错Server会无感知无条件的信任Client传过来的D，就有可能出现问题了，所以采用只传策略和参数，并且由双方共同参与，这样安全性和正确性就会提高很多。贴一张整个过程的抓包图作为结尾吧~
&lt;img src=&quot;握手消息过程.png&quot; alt=&quot;握手消息过程.png&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Mar 2017 23:10:00 +0800</pubDate>
        <link>http://yourdomain.com/blog/2017/03/13/https.html</link>
        <guid isPermaLink="true">http://yourdomain.com/blog/2017/03/13/https.html</guid>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>Android消息分发及多线程切换之Handler、Message的细枝末节（二）</title>
        <description>&lt;p&gt;之前说了Android消息分发和多线程切换的核心知识点，这次来说一下消息传递的整个过程，好像上一篇内容不看貌似也可以直接看这篇，不过建议还是看一下可以了解的更透彻一点吧~~&lt;/p&gt;

&lt;p&gt;上一篇请看：http://www.jianshu.com/p/e914cda1b5fe&lt;/p&gt;

&lt;p&gt;下面开始本篇的主题吧，我将按照Handler和Message的一般使用流程，跟着代码调用链一步步往下走，所以，看代码吧！&lt;/p&gt;

&lt;p&gt;首先在主线程定义一个handler：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	Handler handler = new Handler(){
            @Override
            public void handleMessage(Message msg) {
                super.handleMessage(msg);
                switch (msg.what){
                    case TEST:
                        handleTest(msg);
                        break;
                    default:
                        handleDefault(msg);
                        break;
                }
            }
       };
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;然后在工作线程中使用拿到handler的引用，直接使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	new Thread(){
            @Override
            public void run() {
                super.run();
                Message message = Message.obtain();
                message.what = TEST;
                Bundle bundle =new Bundle();
                bundle.putString(&quot;test key&quot;,&quot;test value&quot;);
                message.setData(bundle);
       			handler.sendMessage(msg);                
            }
        }.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;以上即为一个简单使用场景，在工作线程中通过将Message发送到主线程的handler，让handler在主线程中处理UI相关的操作。&lt;/p&gt;

&lt;p&gt;我们从第一段代码开始，先看一下Handler的创建过程。很简单，直接new一个Handler对象，然后实现它的&lt;strong&gt;handleMessage(Message msg)&lt;/strong&gt;方法，但是这个handler可不是随便哪里都能创建的，相信很多同学肯定也碰到过在别的线程中创建handler报错的情况，类似&lt;code class=&quot;highlighter-rouge&quot;&gt;Can&#39;t create handler inside thread that has not called Looper.prepare()&lt;/code&gt;这样的错误提示，为啥呢？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
     * Default constructor associates this handler with the {@link Looper} for the
     * current thread.
     *
     * If this thread does not have a looper, this handler won&#39;t be able to receive messages
     * so an exception is thrown.
     */
    public Handler() {
        this(null, false);
    }
    
   
    public Handler(Callback callback, boolean async) {
        if (FIND_POTENTIAL_LEAKS) {
            final Class&amp;lt;? extends Handler&amp;gt; klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;amp;&amp;amp;
                    (klass.getModifiers() &amp;amp; Modifier.STATIC) == 0) {
                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                    klass.getCanonicalName());
            }
        }

        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                &quot;Can&#39;t create handler inside thread that has not called Looper.prepare()&quot;);
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }
    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最终调用到的构造器中的第一处判断是用来检测内存泄露相关的，我们不管，看&lt;strong&gt;mLooper&lt;/strong&gt;变量的赋值：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
     * Return the Looper object associated with the current thread.  Returns
     * null if the calling thread is not associated with a Looper.
     */
    public static @Nullable Looper myLooper() {
        return sThreadLocal.get();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;sThreadLocal.get()&lt;/strong&gt;方法上一篇我们讲过了，&lt;strong&gt;sThreadLocal&lt;/strong&gt;是一个全局的静态变量，保存着线程对应的&lt;strong&gt;looper&lt;/strong&gt;对象，&lt;strong&gt;get()&lt;/strong&gt;方法用来获取当前线程对应的&lt;strong&gt;looper&lt;/strong&gt;对象，由于我们这个&lt;strong&gt;handler&lt;/strong&gt;是在主线程中创建的，而主线程在&lt;strong&gt;ActivityThread&lt;/strong&gt;的&lt;strong&gt;main()&lt;/strong&gt;方法中已经为我们创建了对应的&lt;strong&gt;looper&lt;/strong&gt;对象，因此我们这里去get的话是能取到值的，所以下面一行的判断不会抛异常。但是一般的工作线程，我们如果没用为它创建&lt;strong&gt;Looper&lt;/strong&gt;对象，它是没有对应的&lt;strong&gt;Looper&lt;/strong&gt;对象保存在&lt;strong&gt;sThreadLocal&lt;/strong&gt;中的，因此&lt;strong&gt;Looper.myLooper()&lt;/strong&gt;就会返回null，接下去就会报错，也就是上面说的在工作线程中创建handler会报错的原因。取到&lt;strong&gt;mLooper&lt;/strong&gt;之后，将&lt;strong&gt;mLooper&lt;/strong&gt;中的保存&lt;strong&gt;Message&lt;/strong&gt;的&lt;strong&gt;MessageQueue&lt;/strong&gt;也取出保存在&lt;strong&gt;handler&lt;/strong&gt;的属性&lt;strong&gt;mQueue&lt;/strong&gt;中，然后将构造器的参数&lt;strong&gt;callback&lt;/strong&gt;和&lt;strong&gt;async&lt;/strong&gt;赋值，我们这里都为null。&lt;/p&gt;

&lt;p&gt;这里大致介绍下&lt;strong&gt;Handler&lt;/strong&gt;的几个属性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;boolean mAsynchronous：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这个是用来表明处理&lt;strong&gt;Message&lt;/strong&gt;的时候是否需要保证顺序，默认为false，而且我们其实也没办法去将他设置为true，因为这些构造器都是&lt;code class=&quot;highlighter-rouge&quot;&gt;@hide&lt;/code&gt;的，所以我们可以不管它。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Callback mCallback：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这个是Handler的内部接口&lt;strong&gt;Callback&lt;/strong&gt;类型的一个属性，它就一个方法，也叫
&lt;strong&gt;handleMessage(Message msg)&lt;/strong&gt;,只能在构造器中传参，如果我们在构造器中给了这个参数，那么发送给这个&lt;strong&gt;handler&lt;/strong&gt;的消息将优先会由这个&lt;strong&gt;mCallback&lt;/strong&gt;来执行，不过目前为止我并不清楚哪些场景适用这种方式，知道的同学欢迎指教一下~&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Looper mLooper:&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;handler&lt;/strong&gt;是用来处理&lt;strong&gt;Message&lt;/strong&gt;的，因此我们必须要有&lt;strong&gt;Message&lt;/strong&gt;来源，而&lt;strong&gt;Message&lt;/strong&gt;的来源&lt;strong&gt;MessageQueue&lt;/strong&gt;是在&lt;strong&gt;Looper&lt;/strong&gt;中的，因此&lt;strong&gt;handler&lt;/strong&gt;需要一个&lt;strong&gt;Looper&lt;/strong&gt;属性。一般情况下&lt;strong&gt;mLooper&lt;/strong&gt;即为主线程或者说是创建它的线程所对应的&lt;strong&gt;Looper&lt;/strong&gt;,但是我们也可以传一个Looper对象给它，关于这个可以看看&lt;code class=&quot;highlighter-rouge&quot;&gt;HandlerThread&lt;/code&gt;的相关知识。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MessageQueue mQueue：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;没啥好说的，这个就是&lt;strong&gt;handler&lt;/strong&gt;要处理的消息的来源了,它和&lt;strong&gt;Looper&lt;/strong&gt;中的&lt;strong&gt;mQueue&lt;/strong&gt;指向同一个对象。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在看一下&lt;strong&gt;Handler&lt;/strong&gt;的消息分发方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
     * Handle system messages here.
     */
    public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
    
    private static void handleCallback(Message message) {
        message.callback.run();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;还记得上一篇中最后线程停留的那个死循环吗，里面有一行代码&lt;code class=&quot;highlighter-rouge&quot;&gt; msg.target.dispatchMessage(msg);&lt;/code&gt;,这里每次取出的&lt;strong&gt;Message&lt;/strong&gt;都会被它对应的&lt;strong&gt;target&lt;/strong&gt;也就是&lt;strong&gt;Handler&lt;/strong&gt;对象分发，也就是上面这段代码。&lt;/p&gt;

&lt;p&gt;可以看到首先会判断&lt;strong&gt;Message&lt;/strong&gt;对象自己的&lt;strong&gt;callback&lt;/strong&gt;是否为空，它是一个&lt;strong&gt;Runnable&lt;/strong&gt;对象，如果不为空直接调用&lt;strong&gt;callback&lt;/strong&gt;的&lt;strong&gt;run()&lt;/strong&gt;方法，否则判断&lt;strong&gt;handler&lt;/strong&gt;的属性&lt;strong&gt;mCallback&lt;/strong&gt;是否为空，属性介绍的时候已经讲过这个了，如果不为空则则调用&lt;strong&gt;mCallback.handleMessage(msg)&lt;/strong&gt;方法，这个方法返回true就直接return，否则调用&lt;strong&gt;handler&lt;/strong&gt;的&lt;strong&gt;handlerMessage(msg)&lt;/strong&gt;方法，也就是我们要继承&lt;strong&gt;Handler&lt;/strong&gt;要实现的方法，这个是不是有点类似于Android系统的屏幕事件传递机制呢？哈哈~&lt;/p&gt;

&lt;p&gt;话说第一篇里有个坑还没填，就是如何在工作线程创建使用&lt;strong&gt;Handler&lt;/strong&gt;，不过相信看到这里的同学应该已经心里有底了吧，参考上一篇中&lt;strong&gt;ActivityThread&lt;/strong&gt;中的&lt;strong&gt;main()&lt;/strong&gt;方法，很容易创建自己的无线循环工作线程了，下面直接给出代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	new Thread(){
            Handler handler;
            @Override
            public void run() {
                super.run();
                Looper.prepare();
                 handler = new Handler(){
                    @Override
                    public void handleMessage(Message msg) {
                        super.handleMessage(msg);
                        //handler the message
                    }
                };
                Looper.loop();
            }
        };
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;以上，即在工作线程中创建了&lt;strong&gt;handler&lt;/strong&gt;,然后将&lt;strong&gt;handler&lt;/strong&gt;的引用丢给别的线程，别的线程就可以通过&lt;strong&gt;handler&lt;/strong&gt;发消息到这个工作线程来处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Handler&lt;/strong&gt;对于消息的分发和处理的逻辑总算说完了，接下去看看&lt;strong&gt;Message&lt;/strong&gt;是如何被送到&lt;strong&gt;Handler&lt;/strong&gt;的。
先看下&lt;strong&gt;Message&lt;/strong&gt;的基本信息吧：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;int what:&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;表明消息的类别，&lt;strong&gt;handler&lt;/strong&gt;根据这个字段来判断如何处理这个&lt;strong&gt;Message&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Bundle data：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;用于存放数据，可以存放一些相对复杂的内容，因此开销稍微大一点&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;int arg1,arg2:&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;两个基本类型的参数，用于传递一些简单的&lt;strong&gt;Message&lt;/strong&gt;信息，可以的话尽量用这两个参数来传递信息，相对于&lt;strong&gt;Bundle data&lt;/strong&gt;它性能消耗会小很多&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;int flags:&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;当前&lt;strong&gt;Message&lt;/strong&gt;状态的一个标志位，类似异步，使用中这些状态&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;long when：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;表示这个&lt;strong&gt;Message&lt;/strong&gt;应该在何时被执行，&lt;strong&gt;MessageQueue&lt;/strong&gt;中&lt;strong&gt;Message&lt;/strong&gt;就是以这个字段为来排序的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Handler target：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Message&lt;/strong&gt;将要被发送的对象，也就是由哪个target来接受处理这个&lt;strong&gt;Message&lt;/strong&gt;，&lt;strong&gt;这个字段必须不为null&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Runnable callback：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这个讲&lt;strong&gt;handler&lt;/strong&gt;的时候说到过了，如果有这个字段，那么这个&lt;strong&gt;Message&lt;/strong&gt;将由此&lt;strong&gt;callback&lt;/strong&gt;来处理，注意下，它是一个&lt;strong&gt;Runnable&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Message next:&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;由于&lt;strong&gt;Message&lt;/strong&gt;在消息池中是链表的形式维护的，所以这个字段表示下一个&lt;strong&gt;Message&lt;/strong&gt;对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;static Message sPool：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这个是静态变量，指向当前消息池的第一个空闲&lt;strong&gt;Message&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;static int sPoolSize:&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;消息池的大小，也就是剩余空闲&lt;strong&gt;Message&lt;/strong&gt;的数量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;static final int MAX_POOL_SIZE = 50;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;不用解释了吧？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再贴一下例子中的第二段代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	new Thread(){
            @Override
            public void run() {
                super.run();
                Message message = Message.obtain();
                message.what = TEST;
                Bundle bundle =new Bundle();
                bundle.putString(&quot;test key&quot;,&quot;test value&quot;);
                message.setData(bundle);
       			handler.sendMessage(msg);                
            }
        }.start();
        
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Message&lt;/strong&gt;的获取方式特别多，除了自己new一个外，其他基本都大同小异，最终都从&lt;strong&gt;Message&lt;/strong&gt;消息池取一个空闲的&lt;strong&gt;Message&lt;/strong&gt;使用，因为Android系统中到处都用到了&lt;strong&gt;Message&lt;/strong&gt;，因此会需要大量的&lt;strong&gt;Message&lt;/strong&gt;对象，使用消息池的方式可以减少频繁的创建销毁对象，大大的提高性能。我这里直接用最基本的方式获取，&lt;code class=&quot;highlighter-rouge&quot;&gt;Message.obtain();&lt;/code&gt;,看源码吧：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
     * Return a new Message instance from the global pool. Allows us to
     * avoid allocating new objects in many cases.
     */
    public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                Message m = sPool;
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                return m;
            }
        }
        return new Message();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;对着上面的字段介绍，很容易看出这个方法的作用就是将消息池的第一个空闲&lt;strong&gt;Message&lt;/strong&gt;拿出来，然后消息池的数量减1，当然如果消息池已经没用空闲&lt;strong&gt;Message&lt;/strong&gt;了，那就new一个返回了。&lt;/p&gt;

&lt;p&gt;例子中只用到了&lt;strong&gt;what&lt;/strong&gt;和&lt;strong&gt;data&lt;/strong&gt;字段，简单给它们赋了值，然后就调用&lt;strong&gt;handler.sendMessage(msg); **将消息发送给了我们在主线程创建的&lt;/strong&gt;handler**了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public final boolean sendMessage(Message msg)
    {
        return sendMessageDelayed(msg, 0);
    }
    
    public final boolean sendMessageDelayed(Message msg, long delayMillis)
    {
        if (delayMillis &amp;lt; 0) {
            delayMillis = 0;
        }
        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
    }
    
    /**
     * Enqueue a message into the message queue after all pending messages
     * before the absolute time (in milliseconds) &amp;lt;var&amp;gt;uptimeMillis&amp;lt;/var&amp;gt;.
     * &amp;lt;b&amp;gt;The time-base is {@link android.os.SystemClock#uptimeMillis}.&amp;lt;/b&amp;gt;
     * Time spent in deep sleep will add an additional delay to execution.
     * You will receive it in {@link #handleMessage}, in the thread attached
     * to this handler.
     * 
     * @param uptimeMillis The absolute time at which the message should be
     *         delivered, using the
     *         {@link android.os.SystemClock#uptimeMillis} time-base.
     *         
     * @return Returns true if the message was successfully placed in to the 
     *         message queue.  Returns false on failure, usually because the
     *         looper processing the message queue is exiting.  Note that a
     *         result of true does not mean the message will be processed -- if
     *         the looper is quit before the delivery time of the message
     *         occurs then the message will be dropped.
     */
    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);
            Log.w(&quot;Looper&quot;, e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;前面两个方法的注释我没贴，因为跟第三个方法内容差不多，而且最终也都是调用第三个方法，所以看了第三个方法的注释和方法体应该很容易明白前两个方法的作用。
第一个方法是直接将消息发送handler处理，所以它使用0毫秒的延时作为参数调用第二个方法，第二个方法判断如果延时小于0则默认给0，因为小于0的延迟也就意味着比当前时间早，当然不可能回到过去处理这个消息了，然后它又将当前时间加上延时，调用了第三个方法，这样第三个方法拿到的时间就是一个绝对值了，然后我们看到了&lt;strong&gt;mQueue&lt;/strong&gt;，这个创建&lt;strong&gt;handler&lt;/strong&gt;的时候我们就看到了，指向主线程对应的&lt;strong&gt;Looper&lt;/strong&gt;中的消息队列，最后return了一个方法调用，看名字终于要加入消息队列了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 	private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;等等，原来我们刚才发送的&lt;strong&gt;Message&lt;/strong&gt;还没对象呢，那啥，我不是说那个对象，正经点儿！所以加入消息队列前先给它一个对象吧！然后如果我们的&lt;strong&gt;handler&lt;/strong&gt;是异步的将&lt;strong&gt;msg&lt;/strong&gt;的&lt;strong&gt;flag&lt;/strong&gt;标志位加上成异步,这下&lt;strong&gt;msg&lt;/strong&gt;开开心心地领着对象去排队了~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	//MessageQueue
	boolean enqueueMessage(Message msg, long when) {
        if (msg.target == null) {
            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);
        }
        if (msg.isInUse()) {
            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);
        }

        synchronized (this) {
            if (mQuitting) {
                IllegalStateException e = new IllegalStateException(
                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);
                Log.w(TAG, e.getMessage(), e);
                msg.recycle();
                return false;
            }

            msg.markInUse();
            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when &amp;lt; p.when) {
                // New head, wake up the event queue if blocked.
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                // Inserted within the middle of the queue.  Usually we don&#39;t have to wake
                // up the event queue unless there is a barrier at the head of the queue
                // and the message is the earliest asynchronous message in the queue.
                needWake = mBlocked &amp;amp;&amp;amp; p.target == null &amp;amp;&amp;amp; msg.isAsynchronous();
                Message prev;
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when &amp;lt; p.when) {
                        break;
                    }
                    if (needWake &amp;amp;&amp;amp; p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // We can assume mPtr != 0 because mQuitting is false.
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;首先判断&lt;strong&gt;Message&lt;/strong&gt;的对象&lt;strong&gt;target&lt;/strong&gt;是否为空(所以说&lt;strong&gt;Message&lt;/strong&gt;不能没有对象&lt;strong&gt;target&lt;/strong&gt;),然后判断&lt;strong&gt;Message&lt;/strong&gt;是否正在使用中,在经历的前面的入队步骤后，我们这个&lt;strong&gt;Message&lt;/strong&gt;都满足了条件，然后进入一个同步块，首先判断是否正在退出中，因为主线程是不可退出的，所以我们也不用考虑，不过里面方法也是一目了然，回收&lt;strong&gt;Message&lt;/strong&gt;,返回&lt;strong&gt;false&lt;/strong&gt;通知上层入队失败。我们继续看满足条件的情况下，将&lt;strong&gt;Message&lt;/strong&gt;标记为在使用中(&lt;code class=&quot;highlighter-rouge&quot;&gt;msg.markInUse()&lt;/code&gt;),给&lt;strong&gt;when&lt;/strong&gt;字段赋值，然后创建一个新对象指向消息队列中的第一个消息&lt;strong&gt;mMessage&lt;/strong&gt;，定义了一个布尔类型的字段&lt;strong&gt;needWake&lt;/strong&gt;,表示是否需要唤醒当前线程，因为没有消息需要处理的时候我们的Looper线程是阻塞的。当消息队列中的第一个消息为&lt;strong&gt;null&lt;/strong&gt;或者我们本次需要入队的消息对象&lt;strong&gt;msg&lt;/strong&gt;的&lt;strong&gt;when&lt;/strong&gt;为0或者小于原来的队首消息的&lt;strong&gt;when&lt;/strong&gt;值，则将&lt;strong&gt;msg&lt;/strong&gt;插入到消息队列的队首，也就是&lt;strong&gt;mMessage&lt;/strong&gt;之前，然后&lt;strong&gt;mMessage&lt;/strong&gt;重新指向新的队首，也就是&lt;strong&gt;msg&lt;/strong&gt;；当那些条件不满足的时候，则需要将&lt;strong&gt;msg&lt;/strong&gt;插入到消息队列中而不是队首，插入的方式也很简单除暴，遍历原队列的消息，依次比对&lt;strong&gt;when&lt;/strong&gt;的值，直到队尾或者找到下一个消息的&lt;strong&gt;when&lt;/strong&gt;值比&lt;strong&gt;msg&lt;/strong&gt;的&lt;strong&gt;when&lt;/strong&gt;值大的时候跳出循环，将&lt;strong&gt;msg&lt;/strong&gt;插到其中，这个入队的过程也就完成了，都是一些链表的基本操作。之前也有说到，因为每次有消息进入&lt;strong&gt;mQueue&lt;/strong&gt;，我们都是以这种方式来插入的，所以有序的消息队列就是简单以消息的&lt;strong&gt;when&lt;/strong&gt;的大小来排序的。消息插入到消息队列完成后，判断是否需要唤醒主线程，需要则调用native方法&lt;strong&gt;nativeWake()&lt;/strong&gt;唤醒主线程来处理消息（&lt;code class=&quot;highlighter-rouge&quot;&gt; Message msg = queue.next();//Looper.loop()方法中被唤醒后取出消息并分发处理&lt;/code&gt;）。最后返回&lt;strong&gt;true&lt;/strong&gt;表明消息插入队列成功。这样&lt;strong&gt;Message&lt;/strong&gt;入队的过程就算完成了，是不是挺简单的~&lt;/p&gt;

&lt;p&gt;以上，就是一个完整的消息传递和分发过程。实际使用中，我们用到更多的可能是&lt;code class=&quot;highlighter-rouge&quot;&gt;handler.post(runnable);&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;handler.postDelayed(runnable,delayMillis);&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;view.postDelayed(runnable,delayMillis);&lt;/code&gt;之类的方法，这些方法看上去好像没有&lt;strong&gt;Message&lt;/strong&gt;什么事，但是点进去一看就发现，这个被post的&lt;strong&gt;runnable&lt;/strong&gt;就是&lt;strong&gt;Message&lt;/strong&gt;的&lt;strong&gt;callback&lt;/strong&gt;，简单封装一下就又走上了刚刚讲完的消息传递路线，还没反应过来的回头看看&lt;strong&gt;handler&lt;/strong&gt;的&lt;strong&gt;dispatchMessage(Message msg)&lt;/strong&gt;方法，因此这些方式我们都不用重写&lt;strong&gt;handleMessage(Message msg)&lt;/strong&gt;方法,使用起来非常方便。&lt;strong&gt;&lt;em&gt;友情提示：非常方便的同时也非常容易导致内存泄露、空指针和其他一些状态紊乱的错误（别问我怎么知道的，死过太多脑细胞😭），慎用！！！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 06 Feb 2017 23:10:00 +0800</pubDate>
        <link>http://yourdomain.com/blog/2017/02/06/Android%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E5%8F%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E4%B9%8BHandler-Message%E7%9A%84%E7%BB%86%E6%9E%9D%E6%9C%AB%E8%8A%82(%E4%BA%8C).html</link>
        <guid isPermaLink="true">http://yourdomain.com/blog/2017/02/06/Android%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E5%8F%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E4%B9%8BHandler-Message%E7%9A%84%E7%BB%86%E6%9E%9D%E6%9C%AB%E8%8A%82(%E4%BA%8C).html</guid>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>Android消息分发及多线程切换之Handler、Message的细枝末节（一）</title>
        <description>&lt;p&gt;今天来扒一扒Android的消息分发机制和多线程切换过程，也就是我们常常看到用的Handler，Message（还有两个不太看得到的MessageQueue和Looper）它们的原理。额，当然有人会说还有AsyncTask这玩意儿，怎么说呢，反正我是基本没用过AsyncTask，也没见谁喜欢用这个，总感觉使用起来没Handler+Message方便，然而我用的更多的是Handler+Runnable，当然实际上Runnable还是被包装成了Message。&lt;/p&gt;

&lt;p&gt;先简单介绍一下这几个类吧：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Handler:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

 	处理者，一般在主线程创建（在工作线程也可以创建，这个下一篇会详细说到），处理各种线程发送过来的* Message，根据Message内容在主线程做不同的处理。
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Message:&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;消息体，在多线程中担任一个内容载体的角色，包含了消息的类型，参数，数据等内容，其中还包括一个重要的对象，那就是它将会被发送给那个handler。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MessageQueue：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;消息队列，所有发送给handler处理的消息都会保存在消息队列中，其内部使用链表的形式维护这些message。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Looper：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这个怎么说呢，它的英文解释为一个打环的装置，我也不知道该怎么翻译，它的作用是可以让线程一直活着，而不是执行完一个功能代码后就死掉了，每个Looper的实例有一个MessageQueue和当前线程对象，正是这两个类让线程可以一直活着，也就是Looper打环的装置的意思吧。我们的主线程就是因为它才可以一直执行而不退出。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面说到Looper使我们的主线程可以一直运行，究竟是咋回事，上代码！！！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public static void main(String[] args) {
        ······
        Looper.prepareMainLooper();

        ActivityThread thread = new ActivityThread();
        thread.attach(false);

        if (sMainThreadHandler == null) {
            sMainThreadHandler = thread.getHandler();
        }
		······
        Looper.loop();

        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;没错，就是我们的主线程初始化的地方，也就是应用程序启动的入口。我们的应用对于Android系统而言，说白了也就是一段程序代码，那么程序启动的时候当然得从启动方法开始了，它就是&lt;strong&gt;ActivityThread&lt;/strong&gt;中大名鼎鼎的&lt;strong&gt;main()&lt;/strong&gt;方法，是不是想起来java中的&lt;strong&gt;main()&lt;/strong&gt;方法？我们来看一下这里到底做了哪些事。首先就是调用了&lt;strong&gt;Looper&lt;/strong&gt;的静态方法&lt;strong&gt;preoareMainLooper()&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
     * Initialize the current thread as a looper, marking it as an
     * application&#39;s main looper. The main looper for your application
     * is created by the Android environment, so you should never need
     * to call this function yourself.  See also: {@link #prepare()}
     */
    public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
            }
            sMainLooper = myLooper();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个是源码原封不动的贴上来的，包括注释，可以看到这个方法应该由系统调用，它根据当前线程初始化一个&lt;strong&gt;Looper&lt;/strong&gt;对象，并且是应用的”main looper”，也就是方法名所表现的，接着看方法里的第一行调用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }
    
    private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里有个&lt;strong&gt;sThreadLocal&lt;/strong&gt;，它是一个静态属性：**static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();**，也就是全局就一个，每个线程最多对应一个**Looper**对象，如果有，**Looper**对象都会保存在**sThreadLocal**中，我们简单的把它理解为一个Map就行，key为当前的线程，value为一个**Looper**实例，因为线程（也就是key）在方法调用的时候内部可以取到，所以对它进行get，set操作的时候不需要传key，直接传value就行，那么这个方法就很好理解了，如果之前调用过这个方法，**sThreadLocal.get()**则不为null,直接抛异常（也就说明了一个线程最多只能对应一个**Looper**对象），否则new一个**Looper**对象存到**sThreadLocal**中，**Looper**对象初始化的同时也初始化了一个**MessageQueue**，并且持有了当前线程的引用。&lt;/Looper&gt;&lt;/Looper&gt;&lt;/p&gt;

&lt;p&gt;好，继续看&lt;strong&gt;prepareMainLooper&lt;/strong&gt;方法，判断&lt;strong&gt;sMainLooper&lt;/strong&gt;是否为null，第一次调用当然为null，所以&lt;strong&gt;sMainLooper = myLooper();&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
     * Return the Looper object associated with the current thread.  Returns
     * null if the calling thread is not associated with a Looper.
     */
    public static @Nullable Looper myLooper() {
        return sThreadLocal.get();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;很简单，直接调用&lt;strong&gt;sThreadLocal.get()&lt;/strong&gt;方法，很眼熟是吧，我们刚刚调用过它的&lt;strong&gt;set()&lt;/strong&gt;方法，这个时候还在刚才的线程中呢，所以这里取出来的就是我们刚刚放进去的&lt;strong&gt;new Looper()&lt;/strong&gt;，可以稍微看一下这个过程中有个参数就&lt;strong&gt;quitAllowed&lt;/strong&gt;，最终被传到了&lt;strong&gt;MessageQueue&lt;/strong&gt;的构造器中，应该可以猜到它表示这个&lt;strong&gt;MessageQueue&lt;/strong&gt;是否可以被退出或者说这个线程是否能被结束掉，当然因为我们的线程是主线程，所以传&lt;strong&gt;false&lt;/strong&gt;。目前为止我们已经完成了&lt;strong&gt;prepareMainLooper()&lt;/strong&gt;方法，它所做的事其实很简单，就是将我们的线程作为key在&lt;strong&gt;sThreadLocal&lt;/strong&gt;中保存了一个不可退出的&lt;strong&gt;Looper&lt;/strong&gt;对象，同时赋值给&lt;strong&gt;sMainLooper&lt;/strong&gt;，为什么还要单独定义一个&lt;strong&gt;sMainLooper&lt;/strong&gt;呢？首先&lt;strong&gt;sMainLooper&lt;/strong&gt;是一个静态属性，且有一个&lt;strong&gt;getMainLooper()&lt;/strong&gt;静态方法直接返回&lt;strong&gt;sMainLooper&lt;/strong&gt;,所以我猜测是因为主线程的&lt;strong&gt;Looper&lt;/strong&gt;对象获取比较频繁，所以单独作为一个属性直接读取，省的每次从&lt;strong&gt;sThreadLocal&lt;/strong&gt;中去取，以此减小开销。&lt;/p&gt;

&lt;p&gt;下面放一张图作为prepareMainLooper的总结吧，对着图看应该清晰很多：
&lt;img src=&quot;prepareMainLooper.001.jpeg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;回头继续看&lt;strong&gt;main()&lt;/strong&gt;方法，接下去new了一个ActivityThread实例&lt;strong&gt;thread&lt;/strong&gt;，并且调用了&lt;strong&gt;attach()&lt;/strong&gt;方法，然后将&lt;strong&gt;thread.getHandler()&lt;/strong&gt;返回给&lt;strong&gt;sMainThreadHandler&lt;/strong&gt;，这几行代码主要是初始化了我们的应用进程和Android系统的通信基础，也就是Binder组件，使得我们的应用进程和Android系统能够通信，这里我们只要知道个大概，就是Android系统会发送消息给我们的应用的&lt;strong&gt;ActivityThread&lt;/strong&gt;(好吧，其实是它的一个内部类&lt;strong&gt;ApplicationThread&lt;/strong&gt;)，然后由&lt;strong&gt;ActivityThread&lt;/strong&gt;包装成&lt;strong&gt;Message&lt;/strong&gt;放入&lt;strong&gt;sMainLooper&lt;/strong&gt;的&lt;strong&gt;MessageQueue&lt;/strong&gt;中等待执行。如何执行，请往下看……&lt;/p&gt;

&lt;p&gt;再接下去是&lt;strong&gt;Looper.loop()&lt;/strong&gt;方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
     * Run the message queue in this thread. Be sure to call
     * {@link #quit()} to end the loop.
     */
    public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);
        }
        final MessageQueue queue = me.mQueue;
		······
        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }

          	······

            msg.target.dispatchMessage(msg);

            ······

            msg.recycleUnchecked();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;可以看到以上代码逻辑也十分简单，获取当前线程的&lt;strong&gt;Looper&lt;/strong&gt;对象，进而获取&lt;strong&gt;Looper&lt;/strong&gt;对象中的&lt;strong&gt;MessageQueue&lt;/strong&gt;保存为&lt;strong&gt;queue&lt;/strong&gt;，然后进入死循环，每次都从&lt;strong&gt;queue&lt;/strong&gt;中取下一个&lt;strong&gt;Message&lt;/strong&gt;，得到&lt;strong&gt;Message&lt;/strong&gt;后直接调用&lt;strong&gt;Message&lt;/strong&gt;对象中保存的目标&lt;strong&gt;handler&lt;/strong&gt;的&lt;strong&gt;dispatchMessage（）&lt;/strong&gt;方法，然后回收&lt;strong&gt;Message&lt;/strong&gt;进入下一次循环。至此，我们的主线程才成为了真正意义上的主线程。上面说到Android系统会给我们应用发消息，然后消息被包装成&lt;strong&gt;Message&lt;/strong&gt;保存在&lt;strong&gt;MessageQueue&lt;/strong&gt;中，而在&lt;strong&gt;loop()&lt;/strong&gt;方法中我们又去取下一个&lt;strong&gt;Message&lt;/strong&gt;，是不是发现了什么？不错，我们应用中的各种系统方法的调用其实都是都将Android系统发送的消息包装成&lt;strong&gt;Message&lt;/strong&gt;保存到我们的应用主线程绑定的&lt;strong&gt;sMainLooper&lt;/strong&gt;中的&lt;strong&gt;MessageQueue&lt;/strong&gt;中，然后由这个死循环从&lt;strong&gt;MessageQueue&lt;/strong&gt;中取依次出&lt;strong&gt;Message&lt;/strong&gt;消息进而执行对应的方法，这样一个完整的消息传递过程就打通了！&lt;/p&gt;

&lt;p&gt;老样子，看图：
&lt;img src=&quot;loop.001.jpeg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我个人认为以上内容已经是&lt;strong&gt;Handler&lt;/strong&gt;和&lt;strong&gt;Message&lt;/strong&gt;完成多线程切换和消息传递的核心内容了，主要也就是&lt;strong&gt;Looper&lt;/strong&gt;类的用处和用法，看懂了这些内容再看整个流程会很轻松，所以如果还没理解的话建议再看几遍，或者直接去看看Looper的源码更好。&lt;/p&gt;

&lt;p&gt;其实还一个比较关键的步骤：如何从&lt;strong&gt;MessageQueue&lt;/strong&gt;取&lt;strong&gt;Message&lt;/strong&gt;，不过个人感觉就算这个过程对于理解整个消息传递机制影响不大，只要知道&lt;strong&gt;MessageQueue&lt;/strong&gt;以链表的形式维护这每个进入队列的&lt;strong&gt;Message&lt;/strong&gt;就行了。有兴趣的小伙伴也可以看看源码，我就在这里贴一下&lt;strong&gt;MessageQueue.next()&lt;/strong&gt;方法的源码吧：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	Message next() {
        // Return here if the message loop has already quit and been disposed.
        // This can happen if the application tries to restart a looper after quit
        // which is not supported.
        final long ptr = mPtr;
        if (ptr == 0) {
            return null;
        }

        int pendingIdleHandlerCount = -1; // -1 only during first iteration
        int nextPollTimeoutMillis = 0;
        for (;;) {
            if (nextPollTimeoutMillis != 0) {
                Binder.flushPendingCommands();
            }

            nativePollOnce(ptr, nextPollTimeoutMillis);

            synchronized (this) {
                // Try to retrieve the next message.  Return if found.
                final long now = SystemClock.uptimeMillis();
                Message prevMsg = null;
                Message msg = mMessages;
                if (msg != null &amp;amp;&amp;amp; msg.target == null) {
                    // Stalled by a barrier.  Find the next asynchronous message in the queue.
                    do {
                        prevMsg = msg;
                        msg = msg.next;
                    } while (msg != null &amp;amp;&amp;amp; !msg.isAsynchronous());
                }
                if (msg != null) {
                    if (now &amp;lt; msg.when) {
                        // Next message is not ready.  Set a timeout to wake up when it is ready.
                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                    } else {
                        // Got a message.
                        mBlocked = false;
                        if (prevMsg != null) {
                            prevMsg.next = msg.next;
                        } else {
                            mMessages = msg.next;
                        }
                        msg.next = null;
                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);
                        msg.markInUse();
                        return msg;
                    }
                } else {
                    // No more messages.
                    nextPollTimeoutMillis = -1;
                }

                // Process the quit message now that all pending messages have been handled.
                if (mQuitting) {
                    dispose();
                    return null;
                }

                // If first time idle, then get the number of idlers to run.
                // Idle handles only run if the queue is empty or if the first message
                // in the queue (possibly a barrier) is due to be handled in the future.
                if (pendingIdleHandlerCount &amp;lt; 0
                        &amp;amp;&amp;amp; (mMessages == null || now &amp;lt; mMessages.when)) {
                    pendingIdleHandlerCount = mIdleHandlers.size();
                }
                if (pendingIdleHandlerCount &amp;lt;= 0) {
                    // No idle handlers to run.  Loop and wait some more.
                    mBlocked = true;
                    continue;
                }

                if (mPendingIdleHandlers == null) {
                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
                }
                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
            }

            // Run the idle handlers.
            // We only ever reach this code block during the first iteration.
            for (int i = 0; i &amp;lt; pendingIdleHandlerCount; i++) {
                final IdleHandler idler = mPendingIdleHandlers[i];
                mPendingIdleHandlers[i] = null; // release the reference to the handler

                boolean keep = false;
                try {
                    keep = idler.queueIdle();
                } catch (Throwable t) {
                    Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);
                }

                if (!keep) {
                    synchronized (this) {
                        mIdleHandlers.remove(idler);
                    }
                }
            }

            // Reset the idle handler count to 0 so we do not run them again.
            pendingIdleHandlerCount = 0;

            // While calling an idle handler, a new message could have been delivered
            // so go back and look again for a pending message without waiting.
            nextPollTimeoutMillis = 0;
        }
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;本来只想写一篇的，不过感觉好像有点长了，这样的话就再写一篇吧，这篇就当做是理论知识的一个补充，接下去讲讲顺着实际应用过程的线索，一步步是如何将消息放入&lt;strong&gt;MessageQueue&lt;/strong&gt;到最后执行的~&lt;/p&gt;
</description>
        <pubDate>Wed, 25 Jan 2017 23:10:00 +0800</pubDate>
        <link>http://yourdomain.com/blog/2017/01/25/Android%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E5%8F%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E4%B9%8BHandler-Message%E7%9A%84%E7%BB%86%E6%9E%9D%E6%9C%AB%E8%8A%82(%E4%B8%80).html</link>
        <guid isPermaLink="true">http://yourdomain.com/blog/2017/01/25/Android%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E5%8F%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E4%B9%8BHandler-Message%E7%9A%84%E7%BB%86%E6%9E%9D%E6%9C%AB%E8%8A%82(%E4%B8%80).html</guid>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>android类加载机制</title>
        <description>&lt;p&gt;最近在搞android插件化，其中最核心的一点就是如何让插件apk跑起来，其实就利用动态加载，将插件中的类加载到host中。之前也看过android类的加载机制，感觉对于整个过程大致看懂了，然后就开始整插件化，结果碰到问题了又感觉一知半解的，很是不爽，索性放一放插件化，先把android的类加载机制看个明白。这里给自己总结下，加深印象的同时保留笔记。&lt;/p&gt;

&lt;p&gt;首先需要知道的是android中两个主要的classloader，PathClassLoader和DexClassLoader，它们都继承自BaseDexClassLoader，这两个类有什么区别呢？其实看一下它们的源码注释就一目了然了。
因为代码很少，约等于没有，这里直接贴出它们的源码，其实主要是注释：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;PathClassLoader&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package dalvik.system;
/**
 * Provides a simple {@link ClassLoader} implementation that operates on a list
 * of files and directories in the local file system, but does not attempt to
 * load classes from the network. Android uses this class for its system class
 * loader and for its application class loader(s).
 */
public class PathClassLoader extends BaseDexClassLoader {
    /**
     * Creates a {@code PathClassLoader} that operates on a given list of files
     * and directories. This method is equivalent to calling
     * {@link #PathClassLoader(String, String, ClassLoader)} with a
     * {@code null} value for the second argument (see description there).
     *
     * @param dexPath the list of jar/apk files containing classes and
     * resources, delimited by {@code File.pathSeparator}, which
     * defaults to {@code &quot;:&quot;} on Android
     * @param parent the parent class loader
     */
    public PathClassLoader(String dexPath, ClassLoader parent) {
        super(dexPath, null, null, parent);
    }
    /**
     * Creates a {@code PathClassLoader} that operates on two given
     * lists of files and directories. The entries of the first list
     * should be one of the following:
     *
     * &amp;lt;ul&amp;gt;
     * &amp;lt;li&amp;gt;JAR/ZIP/APK files, possibly containing a &quot;classes.dex&quot; file as
     * well as arbitrary resources.
     * &amp;lt;li&amp;gt;Raw &quot;.dex&quot; files (not inside a zip file).
     * &amp;lt;/ul&amp;gt;
     *
     * The entries of the second list should be directories containing
     * native library files.
     *
     * @param dexPath the list of jar/apk files containing classes and
     * resources, delimited by {@code File.pathSeparator}, which
     * defaults to {@code &quot;:&quot;} on Android
     * @param libraryPath the list of directories containing native
     * libraries, delimited by {@code File.pathSeparator}; may be
     * {@code null}
     * @param parent the parent class loader
     */
    public PathClassLoader(String dexPath, String libraryPath,
            ClassLoader parent) {
        super(dexPath, null, libraryPath, parent);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;由注释看可以发现PathClassLoader被用来加载本地文件系统上的文件或目录，但不能从网络上加载，&lt;strong&gt;关键是它被用来加载系统类和我们的应用程序&lt;/strong&gt;，这也是为什么它的两个构造函数中调用父类构造器的时候第二个参数传null，具体的参数意义请看接下来DexClassLoader的注释。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;DexClassLoader&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package dalvik.system;
import java.io.File;
/**
 * A class loader that loads classes from {@code .jar} and {@code .apk} files
 * containing a {@code classes.dex} entry. This can be used to execute code not
 * installed as part of an application.
 *
 * &amp;lt;p&amp;gt;This class loader requires an application-private, writable directory to
 * cache optimized classes. Use {@code Context.getDir(String, int)} to create
 * such a directory: &amp;lt;pre&amp;gt;   {@code
 *   File dexOutputDir = context.getDir(&quot;dex&quot;, 0);
 * }&amp;lt;/pre&amp;gt;
 *
 * &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Do not cache optimized classes on external storage.&amp;lt;/strong&amp;gt;
 * External storage does not provide access controls necessary to protect your
 * application from code injection attacks.
 */
public class DexClassLoader extends BaseDexClassLoader {
    /**
     * Creates a {@code DexClassLoader} that finds interpreted and native
     * code.  Interpreted classes are found in a set of DEX files contained
     * in Jar or APK files.
     *
     * &amp;lt;p&amp;gt;The path lists are separated using the character specified by the
     * {@code path.separator} system property, which defaults to {@code :}.
     *
     * @param dexPath the list of jar/apk files containing classes and
     *     resources, delimited by {@code File.pathSeparator}, which
     *     defaults to {@code &quot;:&quot;} on Android
     * @param optimizedDirectory directory where optimized dex files
     *     should be written; must not be {@code null}
     * @param libraryPath the list of directories containing native
     *     libraries, delimited by {@code File.pathSeparator}; may be
     *     {@code null}
     * @param parent the parent class loader
     */
    public DexClassLoader(String dexPath, String optimizedDirectory,
            String libraryPath, ClassLoader parent) {
        super(dexPath, new File(optimizedDirectory), libraryPath, parent);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;DexClassLoader用来加载jar、apk，其实还包括zip文件或者直接加载dex文件，它可以被用来执行未安装的代码或者未被应用加载过的代码。这里也写出了它需要的四个参数的意思&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;dexPath:需要被加载的文件地址，可以多个，用File.pathSeparator分割&lt;/li&gt;
  &lt;li&gt;optimizedDirectory:dex文件被加载后会被编译器优化，优化之后的dex存放路径，&lt;strong&gt;不可以为null&lt;/strong&gt;。注意，注释中也提到需要一个应用私有的可写的一个路径，以防止应用被注入攻击，并且给出了例子      File dexOutputDir = context.getDir(“dex”, 0);&lt;/li&gt;
  &lt;li&gt;libraryPath：包含libraries的目录列表，plugin中有so文件，需要将so拷贝到sd卡上，然后把so所在的目录当参数传入，同样用File.pathSeparator分割，如果没有则传null就行了,会自动加上系统so库的存放目录&lt;/li&gt;
  &lt;li&gt;parent：父类构造器&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里着重看一下第二个参数，之前说过PathClassLoader中调用父类构造器的时候这个参数穿了null，因为加载app应用的时候我们的apk已经被安装到本地文件系统上了，其内部的dex已经被提取并且执行过优化了，优化之后放在系统目录/data/dalvik-cache下。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;接下来我们看一下类的具体加载过程&lt;/h4&gt;
&lt;p&gt;首先看一段如何使用类加载器加载的调用代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	try {
            File file = view.getActivity().getDir(&quot;dex&quot;,0);
            String optimizedDirectory = file.getAbsolutePath();
            DexClassLoader loader = new DexClassLoader(&quot;需要被加载的dex文件所在的路径&quot;,optimizedDirectory,null,context.getClassLoader());
            loader.loadClass(&quot;需要加载的类的完全限定名&quot;);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里我们就用了自定义了一个DexClassLoaderLoader，并且调用了它的loadClass方法，这样一个需要被使用的类就被我们加载进来了，接下去就可以正常使用这个类了，具体怎么使用我就不多说了，我们还是来研究研究这个类是怎么被加载进来的吧~&lt;/p&gt;

&lt;p&gt;可以看到new DexClassLoader的时候我们用了4个参数，参数意义上面已经讲过了，从上面的源码中可以看到DexClassLoader的构造器中直接调用了父类的构造器，只是将optimizedDirectory路径封装成一个File，具体这些参数是如何被使用的呢，我们往下看。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseDexClassLoader类的构造器&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
     * Constructs an instance.
     *
     * @param dexPath the list of jar/apk files containing classes and
     * resources, delimited by {@code File.pathSeparator}, which
     * defaults to {@code &quot;:&quot;} on Android
     * @param optimizedDirectory directory where optimized dex files
     * should be written; may be {@code null}
     * @param libraryPath the list of directories containing native
     * libraries, delimited by {@code File.pathSeparator}; may be
     * {@code null}
     * @param parent the parent class loader
     */
  public BaseDexClassLoader(String dexPath, File optimizedDirectory,
            String libraryPath, ClassLoader parent) {
        super(parent);
        this.originalPath = dexPath;
        this.pathList =
            new DexPathList(this, dexPath, libraryPath, optimizedDirectory);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;首先也是调用了父类的构造器，但这里只将parent传给父类，即ClassLoader，ClassLoader中做的也很很简单，它内部有个parent属性，正好保存传进来的参数parent,这里可以稍微看一下第三个参数的注释，最后一句说到可以为null，而是否为null又刚好是PathClassLoader和DexClassLoader的区别，那是否为null最终又意味着什么呢？卖个关子先~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	protected ClassLoader(ClassLoader parentLoader) {
        this(parentLoader, false);
    }

    ClassLoader(ClassLoader parentLoader, boolean nullAllowed) {
        if (parentLoader == null &amp;amp;&amp;amp; !nullAllowed) {
            throw new NullPointerException(&quot;parentLoader == null &amp;amp;&amp;amp; !nullAllowed&quot;);
        }
        parent = parentLoader;
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;接下去BaseDexClassLoader给originalPath 和 pathList赋了值，originalPath就是我们传进入的dex文件路径，pathList 是一个new 出来的DexPathList对象，这个DexPathList又是何方神圣？且听慢慢道来。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; /**
     * Constructs an instance.
     *
     * @param definingContext the context in which any as-yet unresolved
     * classes should be defined
     * @param dexPath list of dex/resource path elements, separated by
     * {@code File.pathSeparator}
     * @param libraryPath list of native library directory path elements,
     * separated by {@code File.pathSeparator}
     * @param optimizedDirectory directory where optimized {@code .dex} files
     * should be found and written to, or {@code null} to use the default
     * system directory for same
     */
    public DexPathList(ClassLoader definingContext, String dexPath,
            String libraryPath, File optimizedDirectory) {
        if (definingContext == null) {
            throw new NullPointerException(&quot;definingContext == null&quot;);
        }
        if (dexPath == null) {
            throw new NullPointerException(&quot;dexPath == null&quot;);
        }
        if (optimizedDirectory != null) {
            if (!optimizedDirectory.exists())  {
                throw new IllegalArgumentException(
                        &quot;optimizedDirectory doesn&#39;t exist: &quot;
                        + optimizedDirectory);
            }
            if (!(optimizedDirectory.canRead()
                            &amp;amp;&amp;amp; optimizedDirectory.canWrite())) {
                throw new IllegalArgumentException(
                        &quot;optimizedDirectory not readable/writable: &quot;
                        + optimizedDirectory);
            }
        }
        this.definingContext = definingContext;
        this.dexElements =
            makeDexElements(splitDexPath(dexPath), optimizedDirectory);
        this.nativeLibraryDirectories = splitLibraryPath(libraryPath);
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;别的先不说，先看注释。第四个参数中说到如果optimizedDirectory 为null则使用系统默认路径代替，这个默认路径也就是/data/dalvik-cache/目录，这个一般情况下是没有权限去访问的，所以这也就解释了为什么我们只能用DexClassLoader去加载类而不用PathClassLoader。&lt;/p&gt;

&lt;p&gt;然后接着看代码，显然，前面三个if判断都是用来验证参数的合法性的，之后同样只是做了三个赋值操作，第一个就不说了，保存了实例化DexPathList的classloader，第二个参数的声明是一个Element数组,第三个参数是lib库的目录文件数组，&lt;/p&gt;

&lt;p&gt;```
 private final Element[] dexElements;
 private final File[] nativeLibraryDirectories;&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;看它们之前先看看几个split小函数：&lt;/p&gt;

 	private static ArrayList&lt;File&gt; splitDexPath(String path) {
&lt;/File&gt;&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    return splitPaths(path, null, false);
}

private static File[] splitLibraryPath(String path) {
    ArrayList&amp;lt;File&amp;gt; result = splitPaths(
            path, System.getProperty(&quot;java.library.path&quot;, &quot;.&quot;), true);
    return result.toArray(new File[result.size()]);
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这两个顾名思义就是拿来分割dexPath和libPath，它们内部都调用了splitPaths方法，只是三个参数不一样，其中splitLibraryPath方法中调用splitPaths时的第二个参数仿佛又透露了什么信息，没错，之前介绍DexClassLoader参数中的libraryPath的时候说过，会加上系统so库的存放目录，就是在这个时候添加上去的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 	private static ArrayList&amp;lt;File&amp;gt; splitPaths(String path1, String path2,
            boolean wantDirectories) {
        ArrayList&amp;lt;File&amp;gt; result = new ArrayList&amp;lt;File&amp;gt;();
        splitAndAdd(path1, wantDirectories, result);
        splitAndAdd(path2, wantDirectories, result);
        return result;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;什么啊，原来这个方法也没做什么事啊，只是把参数path1和参数path2又分别调用了下splitAndAdd方法，但是这里创建了一个ArrayList,而且调用splitAndAdd方法的时候都当参数传入了，并且最终返回了这个list，所以我们大胆猜测下，path1和path2最后被分割后的值都存放在了list中返回,看下是不是这么一回事吧：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	private static void splitAndAdd(String path, boolean wantDirectories,
            ArrayList&amp;lt;File&amp;gt; resultList) {
        if (path == null) {
            return;
        }
        String[] strings = path.split(Pattern.quote(File.pathSeparator));
        for (String s : strings) {
            File file = new File(s);
            if (! (file.exists() &amp;amp;&amp;amp; file.canRead())) {
                continue;
            }
            /*
             * Note: There are other entities in filesystems than
             * regular files and directories.
             */
            if (wantDirectories) {
                if (!file.isDirectory()) {
                    continue;
                }
            } else {
                if (!file.isFile()) {
                    continue;
                }
            }
            resultList.add(file);
        }
    }
 ```
 果然，跟我们猜的一样，只是又加上了文件是否存在以及是否可读的验证，然后根据参数wantDirectories判断是否文件类型是被需要的类型，最终加入list。现在我们回过头去看看splitDexPath方法和splitLibraryPath方法，是不是一目了然了。
 
 再往上看DexPathList的构造器，nativeLibraryDirectories的最终值也已经知道了，就差dexElements了，makeDexElements方法的两个参数我们也已经知道了，那我们就看看makeDexElements都干了些什么吧。
 
 ```
  	private static Element[] makeDexElements(ArrayList&amp;lt;File&amp;gt; files,
            File optimizedDirectory) {
        ArrayList&amp;lt;Element&amp;gt; elements = new ArrayList&amp;lt;Element&amp;gt;();
        /*
         * Open all files and load the (direct or contained) dex files
         * up front.
         */
        for (File file : files) {
            ZipFile zip = null;
            DexFile dex = null;
            String name = file.getName();
            if (name.endsWith(DEX_SUFFIX)) {
                // Raw dex file (not inside a zip/jar).
                try {
                    dex = loadDexFile(file, optimizedDirectory);
                } catch (IOException ex) {
                    System.logE(&quot;Unable to load dex file: &quot; + file, ex);
                }
            } else if (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)
                    || name.endsWith(ZIP_SUFFIX)) {
                try {
                    zip = new ZipFile(file);
                } catch (IOException ex) {
                    /*
                     * Note: ZipException (a subclass of IOException)
                     * might get thrown by the ZipFile constructor
                     * (e.g. if the file isn&#39;t actually a zip/jar
                     * file).
                     */
                    System.logE(&quot;Unable to open zip file: &quot; + file, ex);
                }
                try {
                    dex = loadDexFile(file, optimizedDirectory);
                } catch (IOException ignored) {
                    /*
                     * IOException might get thrown &quot;legitimately&quot; by
                     * the DexFile constructor if the zip file turns
                     * out to be resource-only (that is, no
                     * classes.dex file in it). Safe to just ignore
                     * the exception here, and let dex == null.
                     */
                }
            } else {
                System.logW(&quot;Unknown file type for: &quot; + file);
            }
            if ((zip != null) || (dex != null)) {
                elements.add(new Element(file, zip, dex));
            }
        }
        return elements.toArray(new Element[elements.size()]);
    }
 ```
 方法也不长，我们一段段看下去。首先创建了一个elememt 列表，然后遍历由dexpath分割得来的文件列表，其实一般使用场景下也就一个文件。循环里面针对每个file 声明一个zipfile和一个dexfile，判断file的文件后缀名，如果是&quot;.dex&quot;则使用loadDexFile方法给dex赋值，如果是“.apk”,“.jar”,“.zip”文件的则把file包装成zipfile赋值给zip，然后同样是用loadDexFile方法给dex赋值，如果是其他情况则不做处理，打印日志说明文件类型不支持，而且下一个if判断中由于zip和dex都未曾赋值，所以也不会添加到elements列表中去。注意下：这里所谓的文件类型仅仅是指文件的后缀名而已，并不是文件的实际类型，比如我们将.zip文件后缀改成.txt，那么就不支持这个文件了。而且我们可以看到对于dexpath目前只支持“.dex”、“.jar”、“.apk”、“.zip”这四种类型。
 
 现在还剩下两个东西可能还不太明确，一个是什么是DexFile以及这里的loadDexFile方法是如何创建dexfile实例的，另一个是什么是Elememt，看了下Element源码，哈哈，so easy，就是一个简单的数据结构体加一个方法，所以我们就先简单把它当做一个存储了file，zip，dex三个字段的一个实体类。那么就剩下DexFile了。
 
 
 ```
 	private static DexFile loadDexFile(File file, File optimizedDirectory)
            throws IOException {
        if (optimizedDirectory == null) {
            return new DexFile(file);
        } else {
            String optimizedPath = optimizedPathFor(file, optimizedDirectory);
            return DexFile.loadDex(file.getPath(), optimizedPath, 0);
        }
    }
    
    
 ```
 很简洁，如果optimizedDirectory == null则直接new 一个DexFile，否则就使用DexFile.loadDex来创建一个DexFile实例。
 
 ```
 /**
     * Converts a dex/jar file path and an output directory to an
     * output file path for an associated optimized dex file.
     */
    private static String optimizedPathFor(File path,
            File optimizedDirectory) {
        /*
         * Get the filename component of the path, and replace the
         * suffix with &quot;.dex&quot; if that&#39;s not already the suffix.
         *
         * We don&#39;t want to use &quot;.odex&quot;, because the build system uses
         * that for files that are paired with resource-only jar
         * files. If the VM can assume that there&#39;s no classes.dex in
         * the matching jar, it doesn&#39;t need to open the jar to check
         * for updated dependencies, providing a slight performance
         * boost at startup. The use of &quot;.dex&quot; here matches the use on
         * files in /data/dalvik-cache.
         */
        String fileName = path.getName();
        if (!fileName.endsWith(DEX_SUFFIX)) {
            int lastDot = fileName.lastIndexOf(&quot;.&quot;);
            if (lastDot &amp;lt; 0) {
                fileName += DEX_SUFFIX;
            } else {
                StringBuilder sb = new StringBuilder(lastDot + 4);
                sb.append(fileName, 0, lastDot);
                sb.append(DEX_SUFFIX);
                fileName = sb.toString();
            }
        }
        File result = new File(optimizedDirectory, fileName);
        return result.getPath();
    }
 ```
 这个方法获取被加载的dexpath的文件名，如果不是“.dex”结尾的就改成“.dex”结尾，然后用optimizedDirectory和新的文件名构造一个File并返回该File的路径，所以DexFile.loadDex方法的第二个参数其实是dexpath文件对应的优化文件的输出路径。比如我要加载一个dexpath为“sdcard/coder_yu/plugin.apk”，optimizedDirectory 为使用范例中的目录的话，那么最终优化后的输出路径为/data/user/0/com.coder_yu.test/app_dex/plugin.dex,具体的目录在不同机型不同rom下有可能会不一样。
 
是时候看看DexFile了。在上面的loadDexFile方法中我们看到optimizedDirectory参数为null的时候直接返回new DexFile（file）了，否则返回 DexFile.loadDex(file.getPath(), optimizedPath, 0)，但其实他们最终都是使用了相同方法去加载dexpath文件，因为DexFile.loadDex方法内部也是直接调用的了DexFile的构造器，以下：
 
 ```
 	static public DexFile loadDex(String sourcePathName, String outputPathName,
        int flags) throws IOException {
        return new DexFile(sourcePathName, outputPathName, flags);
    }
 ```
 然后看看DexFile的构造器吧
 
 ```
 
 	public DexFile(File file) throws IOException {
        this(file.getPath());
    }
    /**
     * Opens a DEX file from a given filename. This will usually be a ZIP/JAR
     * file with a &quot;classes.dex&quot; inside.
     *
     * The VM will generate the name of the corresponding file in
     * /data/dalvik-cache and open it, possibly creating or updating
     * it first if system permissions allow.  Don&#39;t pass in the name of
     * a file in /data/dalvik-cache, as the named file is expected to be
     * in its original (pre-dexopt) state.
     *
     * @param fileName
     *            the filename of the DEX file
     *
     * @throws IOException
     *             if an I/O error occurs, such as the file not being found or
     *             access rights missing for opening it
     */
    public DexFile(String fileName) throws IOException {
        mCookie = openDexFile(fileName, null, 0);
        mFileName = fileName;
        guard.open(&quot;close&quot;);
        //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie);
    }
    
    private DexFile(String sourceName, String outputName, int flags) throws IOException {
        mCookie = openDexFile(sourceName, outputName, flags);
        mFileName = sourceName;
        guard.open(&quot;close&quot;);
        //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie);
    }
 ```
 可以看到直接new DexFile（file）和DexFile.loadDex(file.getPath(), optimizedPath, 0)最终都是调用了openDexFile（sourceName， outputName, flags)方法，只是直接new的方式optimizedPath参数为null，这样openDexFile方法会默认使用 /data/dalvik-cache目录作为优化后的输出目录，第二个构造器的注释中写的很明白了。mCookie是一个int值，保存了openDexFile方法的返回值，openDexFile方法是一个native方法，我们就不深入了，我自己也就看了个大概，有兴趣的同学可以看下这篇文章:
 &amp;lt;http://blog.csdn.net/zhoushishang/article/details/38703623&amp;gt;
 这样总算是创建了一个DexClassLoader。
 
##### 我们回顾一下:从new DexClassLoader(dexPath,optimizedDirectory,libraryPath,parentLoader)开始,调用父类BaseDexClassLoader构造器，用originalPath 保存了 dexPath，pathList保存了一个由dexPath、optimizedDirectory、libraryPath、loader四个参数构建的DexPathList，DexPathList中的definingContext 保存了parentLoader，optimizedDirectory和libraryPath会被分割成数组，其中nativeLibraryDirectories保存了libraryPath被分割后的数组，并且加上了系统so库的目录，dexElements保存了由dexPath被分割后的对应的file而创建的Elememt，它只是一个简单实体类，由一个File，一个ZipFile，一个DexFile组成，ZipFile是由jar、zip、apk形式的file包装成而来，DexFile使用native方法openDexFile打开了具体的file并输出到优化路径。
![image](classloader 关系图.jpg)

---
DexClassLoader的创建过程我们已经看完了，看看它是如何去找到我们需要的类的吧！

先把使用范例再贴一遍

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try {
        File file = view.getActivity().getDir(&quot;dex&quot;,0);
        String optimizedDirectory = file.getAbsolutePath();
        DexClassLoader loader = new DexClassLoader(&quot;需要被加载的dex文件所在的路径&quot;,optimizedDirectory,null,context.getClassLoader());
        loader.loadClass(&quot;需要加载的类的完全限定名&quot;);
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } ``` 我们已经拿到loader了，然后就是loader.loadClass(&quot;需要加载的类的完全限定名&quot;)，我们假设需要被加载的类为 &#39;com.coder_yu.plugin.Test&#39;,也即是loader.loadClass(&quot;com.coder_yu.plugin.Test&quot;),所以我们先去DexClassLoader中看看loaderClass方法，不过好像没有这个方法，那就去它的父类BaseDexClassLoader中看看，还是 没有，那就再往上走，去ClassLoader类里面找，总算找到了：

 public Class&amp;lt;?&amp;gt; loadClass(String className) throws ClassNotFoundException {
    return loadClass(className, false);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;直接调用另一个loadclass方法，看一下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 	protected Class&amp;lt;?&amp;gt; loadClass(String className, boolean resolve) throws ClassNotFoundException {
        Class&amp;lt;?&amp;gt; clazz = findLoadedClass(className);

        if (clazz == null) {
            ClassNotFoundException suppressed = null;
            try {
                clazz = parent.loadClass(className, false);
            } catch (ClassNotFoundException e) {
                suppressed = e;
            }

            if (clazz == null) {
                try {
                    clazz = findClass(className);
                } catch (ClassNotFoundException e) {
                    e.addSuppressed(suppressed);
                    throw e;
                }
            }
        }

        return clazz;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;直接调用findLoadedClass方法，这个方法会去虚拟机中找当前classloader是否已经加载过该class了，如果加载过了则直接返回这个class，否则返回null，并去调用parent的loadClass方法，依次类推，会一直找到根classloader的findLoadedClass方法，因为我们这里是第一次去加载sd卡上的自定义插件，所以肯定没被加载过，那么直到根classloader.findLoadedClass将一直返回null，然后会去调 findClass(className)方法，我们先看一下findLoadedClass方法吧：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; protected final Class&amp;lt;?&amp;gt; findLoadedClass(String className) {
        ClassLoader loader;
        if (this == BootClassLoader.getInstance())
            loader = null;
        else
            loader = this;
        return VMClassLoader.findLoadedClass(loader, className);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;BootClassLoader是ClassLoader的默认parentloader，所以它是加载器链中的顶端，也就是classloader的根节点，因此它会最终代理一些方法到虚拟机去执行，感兴趣的同学可以去看下ClassLoader的源码。这里说一下，其实根节点我们刚才说了是BootClassLoader，而且它重写了loadClass方法，因为它没有parentloader，所以它没有再去调用parent.loadClass(className, false)，而是直接调用findClass方法，而findClass方法中也是直接返回Class.classForName(name, false, null)得到的值，显然结果是null。&lt;/p&gt;

&lt;p&gt;我们构造DexClassLoader的时候给的parentloader参数是context.getClassLoader()，它其实就是加载我们应用的类加载器，也就是PathClassLoader，它的parentloader就是BootClassLoader，这个具体代码我没去找，可以简单的打印下日志就能发现，不过这个情况在instant run 的情况下会有所不同，大家可以去研究研究~有点扯远了，这里我想说的是我们传入的应用类加载器中通过findClass也是加载不到我们需要的类的，所以我们还是得去看我们自定义的DexClassLoader中的findClass方法，DexClassLoader中还是没有重写这个方法，那么还是去BaseDexClassLoader中看吧：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  	@Override
    protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
        Class clazz = pathList.findClass(name);
        if (clazz == null) {
            throw new ClassNotFoundException(name);
        }
        return clazz;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;还记得我们的pathList吗？不记得回头看看上面的图：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  	public Class findClass(String name) {
        for (Element element : dexElements) {
            DexFile dex = element.dexFile;
            if (dex != null) {
                Class clazz = dex.loadClassBinaryName(name, definingContext);
                if (clazz != null) {
                    return clazz;
                }
            }
        }
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Element是不是也很熟悉？就是那个简单的实体类，所以继续到DexFile中去看dex.loadClassBinaryName方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 	public Class loadClassBinaryName(String name, ClassLoader loader) {
        return defineClass(name, loader, mCookie);
    }
    private native static Class defineClass(String name, ClassLoader loader, int cookie);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;最终使用了native方法defineClass去加载我们需要的类，注意参数里有个mCookie，它就是openDexFile方法返回的dex文件返回的int值，这样就将我们需要加载的类和我们的dex文件对应起来了，去从我们给定的dex文件中去加载我们需要的类。&lt;/p&gt;

&lt;p&gt;至此，我们的加载过程就很清楚了。本文所提及的内容并没有什么技术含量，只是顺着一条主线梳理了下整个过程，对于搞明白一些细节可能还是有点帮助。顺带说一下，其实热修复也是用到了这个加载机制，动态的替换掉有bug的类，因为已经被加载过的类不会再被加载，所以只要我们把修复bug后的类放到有bug那个类之前加载，就能解决问题了。&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Jul 2016 23:10:00 +0800</pubDate>
        <link>http://yourdomain.com/blog/2016/07/22/android%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html</link>
        <guid isPermaLink="true">http://yourdomain.com/blog/2016/07/22/android%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html</guid>
        
        
        <category>Blog</category>
        
      </item>
    
      <item>
        <title>android学习之追根溯源</title>
        <description>&lt;p&gt;前几天在公司小组内做了一个android插件化的技术分享，然后被我们jerry大大追杀着要一篇分享，然后我就琢磨着怎么写，难道要把这么大一个主题用一篇文章写完？感觉不现实，况且本身我现在还在拜读人家的代码中，也没这个自信能把所有细节都理解透，解释清楚，所以再三考虑还是决定不误人子弟了……&lt;/p&gt;

&lt;p&gt;不过为了做这个分享，我自己倒是学到了许多。因为要给别人分享，那肯定不能瞎扯啊，别人有疑问那肯定得解释到位啊，对于某些具体的细节不能全靠猜啊，咱得讲证据啊，所以呢，只能逼着自己去撸别人的代码，撸着撸着发现撸不动了，一些地方看不懂，看着好像是干嘛的，但又不确定。如果是平常，可能也就这么过去了，反正大致上能明白怎么回事，但这次为了分享，得讲得出个所以然，也就硬着头皮继续研究下去。这样，往往会学到其他新的知识，比如资源加载机制、应用程序和系统服务之间的交互模式、动态代理、activity的启动过程、广播注册细节等等，其实这些内容即使不知道，也是能漂亮的完成一个app的开发的，毕竟大部分时候我们用不上这些东西。但一直这么下去，也许你就一直仅限于做一些够用的app，而不是一些好用的产品，而且随便一个培训机构出来的小伙就能把你替换了，完全没有自己的竞争力。&lt;/p&gt;

&lt;p&gt;所以呢，说的现实点，为了自己的钱途，我觉得也不应该止步于表面。关于这一点，其实从程序员解决bug的方式就很容易看出来，比如说最常见的NullPointException，最简单快捷的解决办法就是给出错的代码加上非空判断，以前我就是这么做的，然后过几天另一个地方又出现空指针，那就再来一遍呗。就这样，还在为自己解决问题的能力和效率沾沾自喜。殊不知，也许只要把源头找到，这一系列问题就都不会再出现了，这才叫解决bug，才是有意义的代码，而不是无谓的加判断。当然，这个找源头的过程可能并不轻松，但也正是这样才能体现你的能力。&lt;/p&gt;

&lt;p&gt;这些也得感谢现在的老大，在不断的被追问导致这个bug的原因是什么的过程中，让我要成了追根溯源的习惯，而且，在找原因的过程经常会发现一些不知道的细节。所以，没事多问问自己为什么出错，并且找出那个罪恶之源！&lt;/p&gt;
</description>
        <pubDate>Mon, 02 May 2016 23:10:00 +0800</pubDate>
        <link>http://yourdomain.com/blog/2016/05/02/android%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%BD%E6%A0%B9%E6%BA%AF%E6%BA%90.html</link>
        <guid isPermaLink="true">http://yourdomain.com/blog/2016/05/02/android%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%BD%E6%A0%B9%E6%BA%AF%E6%BA%90.html</guid>
        
        
        <category>Blog</category>
        
      </item>
    
  </channel>
</rss>
